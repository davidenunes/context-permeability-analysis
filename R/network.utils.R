#' Reads a complete network based on the data, the configuration
#' and the current run. 
#' 
#' 
#' @description This takes a matrix constructed using the bigmemory package and
#' subsets it based on the configuration id, the run and the layer. This was design for our 
#' experiments in which, for each simulation, we can have more than one layer of networks. 
#' the function \code{read.big.network} merges all the layers (edges are not duplicated). This function 
#' filters the data using an additional column called 'layer'
#' 
#' Note: this is to be used with the package \code{bigmemory}.
#' 
#' requires that the data has the column names:
#' - cfg.id
#' - run
#' - node1 
#' - node2
#' - layer
#' 
#' node1 and node2 are used as the edge list. 
#' 
#' @param data the network data with the above columns
#' @param cfg an integer with the configuration id for the network we wan't to read
#' @param run an integer with the current run
#' @param layer a layer number, it must be between 0 and the maximum number of layers for the filtered
#' data (filtered by cfg and run)
#' 
#' 
#' 
#' @examples
#' require(bigmemory)
#' network_data <- read.big.matrix(filename="../data/regular_networks/networks.csv", header=T, sep=";")
#' network <- read.big.network(data=network_data, cfg=1, run=1, layer=0)
#' 
read.big.network.layer <- function(data, cfg, run, layer){
  
  #filter data by configuration, run, and layer 
  fn_net <- mwhich(x=data, cols=c("run","cfg.id","layer"), vals=list(run,cfg,layer),comps=list("eq"))
  
  #filter data, we just need the edge list
  f_data <- data[fn_net,c("node1","node2")]
  
  network <- read.network(f_data)
  
  return(network)
}

#' Reads a complete network based on the data, the configuration
#' and the current run. The difference between this method and the others
#' is that the network data is subset inside the function based on the 
#' cfg id value and the run. \code{read.network} for instance, requires 
#' an edge list (a data frame with two columns). 
#' 
#' Note: this is to be used with the package \code{bigmemory}.
#' 
#' requires that the data has the column names:
#' - cfg.id
#' - run
#' - node1 
#' - node2
#' 
#' node1 and node2 are used as the edge list. 
#' 
#' @param data the network data with the above columns
#' @param cfg an integer with the configuration id for the network we wan't to read
#' @param run an integer with the current run
#' 
#' These utilities are used with the behave experiment framework so it is expected 
#' that the parameter space with all the available network proprerties, is available. 
#' A unique configuration id is attached to each configuration (set of unique parameter 
#' values). All the data generated by the framework attaches this same configuration 
#' id (cfg.id) to all the data samples generated so that you can cross reference it with 
#' the parameter space instance. 
#' 
#' @examples
#' require(bigmemory)
#' network_data <- read.big.matrix(filename="../data/regular_networks/networks.csv", header=T, sep=";")
#' network <- read.big.network(data=network_data, cfg=1, run=1)
#' 
read.big.network <- function(data, cfg, run){
  
  #filter data by configuration and run 
  fn_net <- mwhich(x=data, cols=c("run","cfg.id"), vals=list(run,cfg),comps=list("eq"))
  
  #filter data, we just need the edge list
  f_data <- data[fn_net,c("node1","node2")]
  
  network <- read.network(f_data)
  
  return(network)
}

#' Reads a matrix of edges and returns a graph
#'
#' @param ndata the network data as a set of network node pairs
#' @param ... expressions evaluated in the context of \code{df} and 
#'   then fed to \code{\link{igraph}}
read.network <- function(ndata){
 
  #load the edge list into an igraph object
  require(igraph)
  graph <- graph.data.frame(d=ndata, directed=FALSE, vertices=NULL)  
  
  return(graph)
}

#' Reads the properties of a given network (an \code{\link{igraph}} object)
#' and returns a matrix with the properties. The names of the properties 
#' are diplayed in the \code{colnames(measure.network(network))}.
#'
#' @param network an igraph object
#' @param ... expressions evaluated in the context of \code{df} and 
#'   then fed to \code{\link{igraph}}
measure.network <- function(network){
  if(!is.igraph(network)){
    stop(paste("The given argument is not an igraph object"))
  }
  
  num_nodes <- length(V(network))
  num_edges <- length(E(network))
  clustering <- transitivity(network, type = c("globalundirected"))
  avplength <- average.path.length(network, directed = FALSE)

  result <- matrix(c(num_nodes,num_edges,clustering,avplength),1)
  colnames(result) <- c("nodes","edges","clustering-coefficient","average-path-length")  

  return(result)
}