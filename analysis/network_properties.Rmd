Context Permeability Investigations
===================================
We now investigate the first variation of the multi-network simulation model we called _Context Permeability_.
We first investigate how different network topologies affect the convergence to consensus.  We change the network 
models and the number of networks in which each agent interacts. Obviously, in this mode, adding more networks means
adding more connections. We show that what is important is not the number of connections but rather the properties they 
display when they are merged. 


# Convergence to Consensus with Regular Networks #
We first investigate how the convergence is affected by regular networks. We use a _K-Regular_ network model 
in which each agent has the same number of connections. The number of connections is controlled by parameter _k_. Each agent has _2*k_ connections. This structure is not very realistic if we compare it with real network structures. Nonetheless, this investigation is useful for two reasons. The first is that we can investigate the influence of connectivity in the convergence to consensus. The second is that these models of interaction can be used outside the 
social simulation domain, nothing prohibits multi-agent systems to use these as models of interaction, we might even want to construct highly clustered networks of agents. Given this, it is valuable to know how the system responds to such structures. 

### Network Generation ###
Each network is generated by placing the nodes in a ring and connecting each node to its next _k-neighbours_. 
The initial order of the nodes in the ring is randomised so that we can have multiple instances of k-regular networks in which agents have different neighbourhoods.

### Multiple k-regular networks ###
We generate multiple _k-regular_ networks and agents are allowed to interact in any one of them. The number of nodes is the same in all the networks. Given that the networks are randomised, neighbourshoods may or may not overlap. What this means is that adding more regular networks is not the same as creating a k-regular network with twice the number of connections. As we will see, the overlapping different k-regular networks changes the original regular properties. Overlapping regular structures can result in the creation of shortcuts between neighbourhoods that would not be created by the regular network generation model. 


In this first experiment we performed experiment with _k-regular_ networks with different _k_ values. We also varied the number of concomitant networks as follows: 

```{r results='asis',echo=FALSE}
source("../R/experiment_utils.R")

#shows the k values explored and the number of networks
params <- read.exp.parameters("../data/regular_networks/param-space_2014-05-30_16:47:53experiment:0_.csv")
params <- params[,c("cfg.id","num.networks","network.0.k")]


k_values <- as.data.frame(unique(params[,"network.0.k"]))
colnames(k_values) <- c("k values")
num_networks <- as.data.frame(unique(params[,"num.networks"]))
colnames(num_networks) <- c("number of networks")

require(stargazer)
stargazer(t(k_values), type="html", summary = FALSE)
stargazer(t(num_networks), type="html", summary = FALSE)

#clean up the environment, I justneed the params for later
gc()
```


First, we load the network data from the regular network experiment. 
This is somehow a large file so we use the `bigmemory` package which 
is more efficient in terms of memory management.
```{r message=FALSE}
source("../R/network.utils.R")
require(bigmemory)
network_data <- read.big.matrix(filename="../data/regular_networks/networks.csv", header=T, sep=";")
```

Before a more detailed analysis lets consider an example. Lets consider 
the scenario where we have _2 networks_ with _k = 10_. We retrieve the 
networks from the first run and make some measurements.

```{r}
#extract networks for num networks = 2 and k = 10 as an example
cfg <- params[params$"num.network" == 2 & params$"network.0.k" == 10,][[1]]

#use the configuration id to filter the data
network1 <- read.big.network.layer(data=network_data,cfg=cfg,run=1, layer=0)

network2 <- read.big.network.layer(data=network_data,cfg=cfg,run=1, layer=1)

#combine the 2 networks
combined_network <- network1 + network2

#some measures

#clustering
network1$cc <- transitivity(network1, type=c("globalundirected")) 
network2$cc <- transitivity(network2, type=c("globalundirected")) 
combined_network$cc <- transitivity(combined_network, type=c("globalundirected")) 

#average path length
network1$apl <- average.path.length(network1, directed=FALSE)
network2$apl <- average.path.length(network2, directed=FALSE)
combined_network$apl <- average.path.length(combined_network, directed=FALSE)

net1 <- c(length(V(network1)), length(E(network1)),network1$cc, network1$apl)
net2 <- c(length(V(network2)), length(E(network2)),network2$cc, network2$apl)
combnet <- c(length(V(combined_network)), length(E(combined_network)),combined_network$cc,combined_network$apl)
netprop.table <- as.data.frame(rbind(net1,net2,combnet))
colnames(netprop.table)<- c("Number of Nodes","Number of Edges","Clustering Coefficient", "Average Path Length")
rownames(netprop.table) <- c("K-Regular 1", "K-Regular 2", "Combined")
```

For this configuration we have two networks in which the agent can interact. In the next figure you can see
the two _k-regular_ networks with _k = 10_ followed by the network that results from merging these two structures. 
The networks are drawn using the _Kamada-Kawai_ Layout which "regards the desirable "geometric" (Euclidean) distance between two vertices in the drawing as the "graph theoretic"" distance between them in the corresponding graph.
```{r fig.width=15, results='asis'}
color1 <- "#7D9C9F"
color2 <- "#B1B1B1"
color_over <- "#FF003F"

E(network1)$color <- color1
E(network2)$color <- color2

el1 <- apply(get.edgelist(network1), 1, paste, collapse="-")
el2 <- apply(get.edgelist(network2), 1, paste, collapse="-")
elc <- apply(get.edgelist(combined_network), 1, paste, collapse="-")

E(combined_network)$color <- ifelse((elc %in% el1) & (elc %in% el2), color_over, ifelse((elc %in% el1), color1, color2))


par(mfrow=c(1,3))
plot(network1,vertex.size = 2, vertex.label=NA, layout =   layout.kamada.kawai, main="10-Regular 1")
plot(network2,vertex.size = 2, vertex.label=NA, layout =   layout.kamada.kawai, main="10-Regular 2")
plot(combined_network,vertex.size = 2, vertex.label=NA, layout =   layout.kamada.kawai, main="Combined 10-Regulars")

stargazer(netprop.table, type="html", summary = FALSE)

#clean up the mess
gc()
```
We can see by the results of the layout that the distance between nodes in the network has decreased, this is confirmed by the decreased average path length of the combined networks. To illustrate our previous point that this is not the same as having a k-regular network with twice the size lets retrieve the setup with 1 k-regular network with _k = 20_. 

```{r results='asis'}
#now lets select a network with twice the k value
#extract networks for num networks = 2 and k = 10 as an example
cfg <- params[params$"num.network" == 1 & params$"network.0.k" == 20,][[1]]

#use the configuration id to filter the data
network_k_20 <- read.big.network.layer(data=network_data,cfg=cfg,run=1, layer=0)

par(mfrow=c(1,1))
plot(network_k_20,vertex.size = 2, vertex.label=NA, layout =   layout.kamada.kawai, main="K-Regular with K=20")
```

As you can see in the following table, while the clustering coefficient of a _20-Regular_ network is approximately the same as the _10-Regulars_, it is higher than this particular combination of regular networks, the average path length also decreases 
as there are more connections between the nodes. 

```{r results='asis'}
network_k_20$cc <- transitivity(network_k_20, type=c("globalundirected")) 
network_k_20$apl <- average.path.length(network_k_20, directed=FALSE)

network_k_20.props <- c(length(V(network_k_20)),
                        length(E(network_k_20)),
                        network_k_20$cc,
                        network_k_20$apl)

netprop.table <- as.data.frame(rbind(net1,net2,combnet,network_k_20.props))

colnames(netprop.table)<- c("Number of Nodes","Number of Edges","Clustering Coefficient", "Average Path Length")
rownames(netprop.table) <- c("10-Regular 1", "10-Regular 2", "Combined 10-Regulars", "20-Regular Network")

require(stargazer)
stargazer(netprop.table, type="html", summary = FALSE)
```

This is not always the case, as we will show, since the nodes are subjected to random permutations to create different instances of _K-Regular_ networks, we can have different overlaps that create different network topologies. 
Obviously, this is not the only difference. From a modelling perspective, different networks can display different properties as well, we can assign different tolerances or trust depending on the network the agent is interacting in. 

#### Merging K-Regular Networks: overlapping ####
We will now investigate, what kind of properties we can get from merging _K-Regular_ networks. We do this 
empirically by taking the network instances used in the simulation and analysing the distribution of clustering coefficient and average path length for the different configurations where we consider multiple networks (from 1 to 5 in this case). 


```{r}
#Collect the network data and create a data table to hold the network properties
require(parallel)

## Number of workers (R processes) to use:
numWorkers <- 8

measure_parallel <- function(cfg,r){
  data <- network_data
  network <- read.big.network(data,cfg,r)
  properties <- measure.network(network)
  properties <- cbind(r,properties)
  return(properties)
}

props <- NULL
num_networks <- c(1,2,3,4,5)
k_values <- c(1:5,seq(10,50,10))
runs <- sort(unique(network_data[,"run"]))

require(BBmisc)#for progress bar
pb <- makeProgressBar(min=0, max=(length(num_networks)*length(k_values)), label="network analysis")

#pre-alocate a matrix for the network properties
props <- matrix(nrow=(length(num_networks)*length(k_values)*length(runs)), ncol=7)
i <- 0


for(n in num_networks){
  #reads the properties for all the k-regular networks with the given k and num_networks 
  for(k in k_values){
    cfg <- params[params$"num.network" == n & params$"network.0.k" == k,][[1]]
    
    properties <- mcmapply(cfg=cfg, r=runs, measure_parallel, mc.cores = numWorkers)
    properties <- t(properties)
    
      
    props[(i+1):(i+100),] <- cbind(k,n,properties)
    i <- i + 100  
    #some progress feddback
    pb$inc(1,paste("reading n=",n,"k=",k,"\n"))
    gc()
  } 
}
pb$kill()

colnames(props)<-c("k","networks","run","nodes","edges","clustering-coefficient","average-path-length")

#clean up
rm(pb)
gc()
```

Creating boxplots to observe the average path length and the clustering coefficient, we can see that these values don't varie much 
within each configuration. Within K-Regular networks we can thus assume certain property values for specific combinations of networks.

```{r}
props <- as.data.frame(props)

require(ggplot2)


#create box plots
net_props <- props[props$networks > 2,]

plot <- plot <- ggplot(net_props, aes(x=as.factor(net_props$networks), y=net_props$"average-path-length",fill=as.factor(net_props$k)) ) 
plot <- plot + geom_boxplot()
plot <- plot + labs(fill="K", y="Average Path Length", x="Number of Networks")
plot 


net_props <- props[props$networks > 0,]

plot <- plot <- ggplot(net_props, aes(x=as.factor(net_props$networks), y=net_props$"clustering-coefficient",fill=as.factor(net_props$k)) ) 
plot <- plot + geom_boxplot()
plot <- plot + labs(fill="K", y="Clustering Coefficient", x="Number of Networks")
plot 
```

We now plot the average value of **average path length** and **clustering coefficient** for a total of 100 K-Regular Networks. We analyse the properties of networks with different levels of **K**. The **number of networks** refers to the number of networks in which the agents
interacted at the same time. As we describe above, these are built merging the networks and suppressing the overllaping edges
between nodes.

```{r}
#aggregate run data by k and networks
require(reshape2)

apl_data <- melt(props, id=c("k","networks","run"),measure.vars=c("average-path-length"))
clustering_data <- melt(props, id=c("k","networks","run"),measure.vars=c("clustering-coefficient"))


average_apl_data <- dcast(apl_data, k + networks ~ variable, mean)
average_clustering_data <- dcast(clustering_data, k + networks ~ variable, mean)


#plot average path length
net_props <- average_apl_data

plot <- ggplot(net_props, aes(x=as.factor(net_props$networks), y=net_props$"average-path-length",)) 

plot <- plot +  geom_point(aes(shape=as.factor(net_props$k), color=as.factor(net_props$k)),size = 3.5)

plot <- plot +  geom_line(aes(color=as.factor(net_props$k), group=as.factor(net_props$k), linetype=as.factor(net_props$k)),size=1)   

plot <- plot + labs(color="K", shape="K", linetype="K", y="Average Path Length", x="Number of Networks")
plot

#clean up
rm(apl_data,average_apl_data)
gc()
```

```{r}
#lets plot the clustering coefficient
net_props <- average_clustering_data

plot <- ggplot(net_props, aes(x=as.factor(net_props$networks), y=net_props$"clustering-coefficient",)) 

plot <- plot +  geom_point(aes(shape=as.factor(net_props$k), color=as.factor(net_props$k)),size = 3.5)

plot <- plot +  geom_line(aes(color=as.factor(net_props$k), group=as.factor(net_props$k), linetype=as.factor(net_props$k)),size=1)   

plot <- plot + labs(color="K", shape="K", linetype="K", y="Clustering Coefficient", x="Number of Networks")
plot

#clean up
rm(clustering_data,average_clustering_data,props, net_props,plot)
gc()
```

In the previous plots we can see that as we increase the number of overllaping networks, the clustering coefficient also increases. The average path lenth decreases as a result from overllapings that create shortcuts between different points in the network. 

The different behaviour for k = {10,20} and k = {30,40,50} can be explained by the fact that networks are overlapped in a random fashion, as such, 
by overlapping networks with less connectivity makes so that our composite networks have shortcuts between different points without the end points of these shortcuts being clustered together. This obviously changes as we add increase k towards 50, which is the configuration where the networks are fully connected. 
